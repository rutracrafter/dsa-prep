## Brute Force Approach
We can just check row by row, column by column, and then 3x3 square by 3x3 square.
``` python
class Solution:
    def isValidSudoku(self, board: List[List[str]]) -> bool:
        seen = set()
        for i in range(len(board)):
            for j in range(len(board[i])):
                num = board[i][j]
                if num in seen:
                    return False
                elif num != '.':
                    seen.add(num)
            seen = set()
        seen = set()
		
        for i in range(len(board)):
            for j in range(len(board[i])):
                num = board[j][i]
                if num in seen:
                    return False
                elif num != '.':
                    seen.add(num)
            seen = set()
  
        seen = set()

        for i in [1, 4, 7]:
            for j in [1, 4, 7]:
                for k in [-1, 0, 1]:
                    for l in [-1, 0, 1]:
                        num = board[i + k][j + l]
                        if num in seen:
                            return False
                        elif num != '.':
                            seen.add(num)
                seen = set()

        return True     
```
The time complexity and space complexity are both O(n^2) for arbitrarily sized sudoku boards, however, because the sudoku board is 9x9, we have that the real time and space complexity is O(1).
## One Pass Approach
We can do this all in one pass by initializing all of the sets that we need beforehand for the rows, cols, and then the 3x3 squares.
``` python

```
The time complexity and space complexity are once again both O(n^2) for arbitrarily sized boards, and O(1) for the fixed 9x9 size.

Key Tak