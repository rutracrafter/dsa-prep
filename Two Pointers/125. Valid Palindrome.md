[Leetcode Problem](https://leetcode.com/problems/valid-palindrome/description/)

## Built-in Approach
Using python's built in functionality, we can do this question by first preprocessing the string to remove any alphanumeric characters and convert all characters to lowercase, then we can just check if the string is equal to the reverse of itself.
``` python
def isPalindrome(self, s: str) -> bool:
	newStr = ""
	for c in s:
		if c.isalnum():
			newStr += c.lower()
	return newStr == newStr[::-1]
```
This solution runs in O(n) time since we first preprocess the string, and then reverse it, however, its space complexity is also O(n) since due to string immutability, when we preprocess the string, we must create a new string of size at most n where n is the size of the original string s.
$x = lim_{n \rightarrow 0} \frac{1}{n}$
## Two Pointer Approach
blah blah blah
``` python
def isPalindrome(self, s: str) -> bool:
	i = 0
	j = len(s) - 1
	while i < j:
		if not s[i].isalnum():
			i += 1
			continue
		if not s[j].isalnum():
			j -= 1
			continue
		if s[i].lower() != s[j].lower():
			return False
		i += 1
		j -= 1
	return True
```