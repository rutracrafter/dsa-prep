## Stack Approach
We can use a stack to keep track of the elements we have, and when we run into an operator, perform that operation on the two elements atop the stack. Watch out for operations that are not commutative, namely subtraction and division.
``` python
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
        stack = []
        for token in tokens:
            if token == '+':
                stack.append(stack.pop() + stack.pop())
            elif token == '-':
                a, b = stack.pop(), stack.pop()
                stack.append(b - a)
            elif token == '*':
                stack.append(stack.pop() * stack.pop())
            elif token == '/':
                a, b = stack.pop(), stack.pop()
                stack.append(int(b / a))
            else:
                stack.append(int(token))
        return stack[0]
```
The time complexity is O(n) since we at most add and then remove each element once from the stack. The space complexity is O(n) since we are using a stack to keep track of the elements, and it grows to length at most n.