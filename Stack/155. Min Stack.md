## Two Stack Approach
We use two stacks to keep track of both the regular stack elements and the minimum element seen thus far. This allows us to keep track of smallest element seen so far, and prevents issues with cases where the min value is removed, but there is no way to update the variable since we don't know what the next smallest element is if it is lower on the stack. We could just search the stack every time we are to return the smallest element, but then we decrease efficiency since we need to check all elements of the stack on every such operation.
``` python
class MinStack:

    def __init__(self):
        self.stack = []
        self.minstack = []

    def push(self, val: int) -> None:
        minval = min(val, self.minstack[-1] if self.minstack else val)
        self.minstack.append(minval)
        self.stack.append(val)

    def pop(self) -> None:
        top = self.stack.pop()
        self.minstack.pop()
        return top

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.minstack[-1]


# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
```
The time complexity is O(1) for all operations. The space complexity is O(n) since we use two stacks to keep track of the stack elements and the min at that point.