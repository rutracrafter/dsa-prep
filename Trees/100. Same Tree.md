## Recursive Approach
For this approach we recursively check whether the left and right subtrees are the same, and return true if both nodes are null, and return false in the case that only one of p or q is null OR in the case that the two node's values are not the same.
``` python
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if p == None and q == None:
            return True
  
        if (p == None or q == None) or (p.val != q.val):
            return False
            
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```
This algorithm runs in O(n) time in the worst case since we visit each node once, and the space complexity is O(n) in the worst case of a highly skewed tree and O(log(n)) in the case of a balanced tree (the space complexity depends on how big the call stack gets).
## Iterative Approach
blah blah blah
``` python
# Code goes here
```
blah blah blah

Key Takeaways:
- When doing recursive problems, take some time to really think about the base case(s) as there can sometimes be more than one which makes some problems quite tricky!