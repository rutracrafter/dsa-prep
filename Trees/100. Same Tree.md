## Recursive Approach
For this approach we recursively check whether the left and right subtrees are the same, and return true if both nodes are null, and return false in the case that only one of p or q is null OR in the case that the two node's values are not the same.
``` python
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        if p == None and q == None:
            return True
  
        if (p == None or q == None) or (p.val != q.val):
            return False
            
        return self.isSameTree(p.left, q.left) and self.isSameTree(p.right, q.right)
```
This algorithm runs in O(n) time in the worst case since we visit each node once, and the space complexity is O(n) in the worst case of a highly skewed tree and O(log(n)) in the case of a balanced tree (the space complexity depends on how big the call stack gets).
## Iterative Approach (Foolish Method)
blah blah blah
``` python
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        sameSubtree = {}
        stack = []
        stack.append((p, q, False))
  
        while len(stack) != 0:
            node1, node2, visited = stack.pop()
  
            if visited:
                if node1 == None and node2 == None:
                    sameSubtree[(node1, node2)] = True
                elif (node1 == None or node2 == None) or (node1.val != node2.val):
                    sameSubtree[(node1, node2)] = False
                elif (sameSubtree.get((node1.left, node2.left), False) and
                    sameSubtree.get((node1.left, node2.left), False)):
                    sameSubtree[(node1, node2)] = True
                else:
                    return False
  
            else:
                if node1 == None or node2 == None:
                    stack.append((node1, node2, True))
                else:
                    stack.append((node1, node2, True))
                    stack.append((node1.right, node2.right, False))
                    stack.append((node1.left, node2.left, False))

        return True
```
blah blah blah
## Iterative Approach (Clever Method)
blah blah blah
``` python
class Solution:
    def isSameTree(self, p: Optional[TreeNode], q: Optional[TreeNode]) -> bool:
        stack = []
        stack.append((p, q))
  
        while len(stack) != 0:
            node1, node2 = stack.pop()

            if node1 == None and node2 == None:
                continue
            elif (node1 == None or node2 == None) or node1.val != node2.val:
                return False

            stack.append((node1.left, node2.left))
            stack.append((node1.right, node2.right))

        return True
```
blah blah blah

Key Takeaways:
- When doing recursive problems, take some time to really think about the base case(s) as there can sometimes be more than one which makes some problems quite tricky!