## Recursive Approach
Keep track of a variable for the maximum diameter, we can perform DFS where at each node, we get the height of the left subtree, the height of the right subtree, update the maximum diameter variable to the max of the current maximum diameter and the sum of the left and right subtree heights, and finally, we return the maximum diameter that we saw during the entire run of DFS.
``` python
class Solution:
	def diameterOfBinaryTree(self, root: Optional[TreeNode]) -> int:
		self.maxDiameter = 0
		def DFS(node):
			if node == None:
				return 0
	
			left = DFS(node.left)
			right = DFS(node.right)
	
			self.maxDiameter = max(self.maxDiameter, left + right)
			return 1 + max(left, right)
	
		DFS(root)
		return self.maxDiameter
```
This solution runs in O(n) time since we visit each node once in our DFS, and O(n) space since in the worst case when dealing with a heavily skewed binary tree, although our space complexity improves to O(log(n)) space in the case where the input tree is a balanced tree.
## Iterative Approach
I am going to come back to this eventually because I racked my brain for a fair bit of time, and I have not yet figured out a clear/efficient iterative Approach to this problem.

Key Takeaways:
- In this problem, the recursive approach must use a helper function/method since what our recursion returns is different to what we are keeping track of (the DFS function returns the height of the passed in node, however, our variable `maxDiameter` is what keeps track of the maximum seen diameter so far).