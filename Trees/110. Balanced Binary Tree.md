## Recursive Approach
Our goal here is to visit each node, and for each node we visit, determine whether the depth of the left and right subtrees differs by more than one, if so, we return false, otherwise, we return true.
``` python
class Solution:
    balanced = True
    def maxDepth(self, root: Optional[TreeNode]) -> int:
        if root == None:
            return 0
  
        leftMaxDepth = self.maxDepth(root.left)
        rightMaxDepth = self.maxDepth(root.right)
  
        if abs(leftMaxDepth - rightMaxDepth) > 1:
            self.balanced = False
  
        return 1 + max(leftMaxDepth, rightMaxDepth)

    def isBalanced(self, root: Optional[TreeNode]) -> bool:
        self.maxDepth(root)
        return self.balanced
```
This approach runs in O(n) time since we visit each node of the tree a single time, and the space complexity is O(n) in the worst case when the tree is a heavily skewed tree, but O(log(n)) in the case of a balanced tree.
## Iterative Approach
We are essentially going to do the same thing here, except this time we shall use a data structure (dictionary/hashtable) to keep track of the height of the subtrees starting at each node.
``` python

```