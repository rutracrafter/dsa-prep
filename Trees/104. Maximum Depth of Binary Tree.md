## Recursive Approach
For an arbitrary node, we can just recursively get the maximum depth between the left and right subtrees and add 1 to it, making sure that our base case is when the node is null.
``` python
def maxDepth(self, root: Optional[TreeNode]) -> int:
	if root == None:
		return 0
	leftDepth = self.maxDepth(root.left)
	rightDepth = self.maxDepth(root.right)

	return 1 + max(leftDepth, rightDepth)
```
This solution run in O(n) time since we are visiting each node exactly once, and the space complexity for this solution is O(n) in the case of a heavily skewed tree, but O(n * log(n)) in the case of a balanced or semi-balanced tree since our call stack will only gets as tall as the height of the tree which is n * log(n).
## Iterative Approach
Rather than using recursion which could explode the call stack, we can use iteration, along with a stack or queue, to perform either DFS or BFS.
### DFS
``` python

```
### BFS
``` python

```
