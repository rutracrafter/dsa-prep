## Recursive Approach
To invert a binary tree (mirror it down the middle), we essentially need to invert its left and right sub tree, and for each of those sub trees, we have to invert the left and right sub trees, and so on. This indicates that we should take a recursive approach!
``` python
def invertTree(self, root: Optional[TreeNode]) -> Optional[TreeNode]:
        if root == None:
            return None
  
        tmp = root.left
        root.left = self.invertTree(root.right)
        root.right = self.invertTree(tmp)
  
        return root
```
This solution runs in O(n) time since we make one call to invertTree for each node of the original tree. Since our stack will only ever get as long as the height of the tree, the space complexity for this problem is O(n) in the worst case since for a very skewed tree, the height of the tree is n, however, in the case of a balanced or semi-balanced tree, our runtime will be O(log(n)) as the height of such a tree would be log(n).
## Iterative Approach
Any problem that can be solved recursively can also be solved 