## Max Heap Approach
We create a max heap for the stones, we pop twice from the max heap, check the condition on the two stones and if necessary, push the new stone onto the max heap.
``` python
class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        maxheap = [(-1 * stone) for stone in stones]
        heapq.heapify(maxheap)
  
        while len(maxheap) > 1:
            stone1 = heapq.heappop(maxheap)
            stone2 = heapq.heappop(maxheap)
            if stone2 != stone1:
                heapq.heappush(maxheap, stone1 - stone2)

        if len(maxheap) == 0:
            return 0
        else:
            return abs(maxheap[0])
```
The time complexity of this code is O(n * log(n)) since in the worst case 