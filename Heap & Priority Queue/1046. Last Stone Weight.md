## Max Heap Approach
We create a max heap for the stones, we pop twice from the max heap, check the condition on the two stones and if necessary, push the new stone onto the max heap.
``` python
class Solution:
    def lastStoneWeight(self, stones: List[int]) -> int:
        maxheap = [(-1 * stone) for stone in stones]
        heapq.heapify(maxheap)
  
        while len(maxheap) > 1:
            stone1 = heapq.heappop(maxheap)
            stone2 = heapq.heappop(maxheap)
            if stone2 != stone1:
                heapq.heappush(maxheap, stone1 - stone2)

        if len(maxheap) == 0:
            return 0
        else:
            return abs(maxheap[0])
```
The time complexity of this algorithm is O(n * log(n)) in the worst case since we have a O(log(n)) worst case operation being done at most n times. The space complexity for this algorithm is O(n) since we store all n stones in our maxheap.
## Sorted List Approach
We are going to essentially do the same thing as above, however, we are going to use a list for our stones this time, we then sort this list, and now both retrieval and insertion of new elements 