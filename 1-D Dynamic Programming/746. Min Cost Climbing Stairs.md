## Recursive Approach
For this approach, we can recursively calculate the min cost of getting to the top from the ith step. Logically, this means that we need to sum the cost of the ith step with the minimum cost to get there. If the ith position we are looking at is before the first step, in other words negative, we return zero as the step doesn't have a cost of its own, or a cost necessary to get to it. We also make sure to take the min of getting to the top step from the last two steps.
``` python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        def minCost(i):
            if i < 0:
                return 0
  
            return cost[i] + min(minCost(i-1), minCost(i-2))
  
        return min(minCost(len(cost) - 1), minCost(len(cost) - 2))
```
The time complexity is O(2^n) since our recursion tree grows exponentially, our time complexity is O(n) since our call stack only grows to at most n.
## Dynamic Programming Approach (Memoization)
The recursive approach has to calculate the result same values multiple times, what if we stored those calculated values to avoid repeat recursive calls?
## Dynamic Programming Approach (Tabulation)
We are going to use an array/list to keep track of the minimum cost to get to step i. To find the minimum cost to get to step i, we need to take the minimum of the cost to get to step i - 1 summed with the cost of step i - 1, and the cost to get to step i - 2 summed with the cost of step i - 2. After the whole array is filled in, we return the minimum of the cost to get to the last step summed with the cost of the last step, and the cost to get to the second to last step summed with the cost of the second to last step.
``` python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        arr = [0] * len(cost)
  
        arr[0] = 0
        arr[1] = 0

        for i in range(2, len(arr)):
            arr[i] = min(arr[i-1] + cost[i-1], arr[i-2] + cost[i-2])

        return min(arr[-1] + cost[-1], arr[-2] + cost[-2])
```
The time complexity is going to be O(n) in the worst case since we would iterate through almost all n elements of the array when filling it in. The space complexity is going to be O(n) in the worst case since we create an array of size O(n).