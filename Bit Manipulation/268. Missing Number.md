## Set Approach
Create a set with the given numbers, check if each number from 0 to length of nums + 1 (inclusive) is in the set, if it isn't return that number.
``` python
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        search_set = set(nums)
        for i in range(len(nums) + 1):
            if i not in search_set:
                return i
```
Time complexity is O(n) in the worst case since creating the set is O(n) and check all the elements the set is O(n). Space complexity is O(n) since the set will hold about n elements.

## Bitwise Approach
This approach is tricky to explain, basically, XOR has a few key properties for this problem (suppose a is either 0 or 1):
- a XOR a = 0
- a XOR 0 = a
- XOR is commutative, this means the order in which we do operations does not matter (think addition, 2+4+8 = 4+2+8 = 8+2+4 = 14)
So now all that we do is XOR all of the numbers in the array with eachother, and XOR that with all the possible values that can be in the array, which will get rid of all the duplicates and leave on the odd one out:
``` python

```