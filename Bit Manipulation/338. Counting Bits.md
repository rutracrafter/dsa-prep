## Bitwise Approach
In this approach we are essentially going to be using the same login as [[191. Number of 1 Bits]] to count the number of 1 bits for each of the values that i takes on.
``` python
class Solution:
    def countBits(self, n: int) -> List[int]:
        result = [0] * (n + 1)
        for i in range(n + 1):
            num = i
            while num:
                num &= (num - 1)
                result[i] += 1
        return result
```
This solution runs in O(n) time since for each value of i (there are n + 1 values of i), we perform a constant time operation (the maximum value of i is 10^5 which is less than 2^17). The space complexity for this solution is O(n) since we end up using an auxiliary array of size n + 1.
## Dynamic Programming Approach 1
We can use the values that we have already calculated to help us in future computations, this problem is tricky, however, because the recurrence relation is not immediately simple. We keep track of an offset variable that will be updated whenever i reaches a new power of 2, or in other words, when the most significant bit increases by one place value to the left.
``` python
class Solution:
    def countBits(self, n: int) -> List[int]:
        dp = [0] * (n + 1)
        offset = 1
        for i in range(1, n + 1):
            if offset * 2 == i:
                offset = i
            dp[i] = 1 + dp[i - offset]
        return dp
```
## Dynamic Programming Approach 2
We can use a very similar approach as above, but this time let's use bitwise operations as they are often faster than regular arithmetic. The idea here is that 
```python
class Solution:
    def countBits(self, n: int) -> List[int]:
        dp = [0] * (n + 1)
        for i in range(1, n + 1):
            dp[i] = dp[i >> 1] + (i & 1)
        return dp
```
This solution runs in O(n) time, and O(n) space.