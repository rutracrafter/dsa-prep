## Bitwise Approach
In this approach we are essentially going to be using the same login as [[191. Number of 1 Bits]] to count the number of 1 bits for each of the values that i takes on.
``` python
class Solution:
    def countBits(self, n: int) -> List[int]:
        result = [0] * (n + 1)
        for i in range(n + 1):
            num = i
            while num:
                num &= (num - 1)
                result[i] += 1
        return result
```
This solution runs in O(n) time since for each value of i (there are n + 1 values of i), we perform a constant time operation (the maximum value of i is 10^5 which is less than 2^17). The space complexity for this solution is O(n) since we end up using an auxiliary array of size n + 1.
## Dynamic Programming Approach 1
We can use the values that we have already calculated to help us in future computations, this problem is tricky, however, because the recurrence relation is not immediately simple. We keep track of an offset variable that will be updated whenever i reaches a new power of 2, or in other words, when the most significant bit 