## Bitwise Approach
We can look at each bit from right to left (least significant bit to most significant bit) and just sum up the number of 1s we see. The easier way to do this is with the bitwise operation '&' to compare the current number with 1 which will return 1 if the number's LSB (least significant bit) is 1, and 0 otherwise.
``` python
class Solution:
    def hammingWeight(self, n: int) -> int:
        setBits = 0
        while n > 0:
            setBits += n & 1
            n = n >> 1
        return setBits
```
This solution runs in O(n) time since we are essentially performing a linear scan of each bit value of the original number. The space complexity is O(1) since we are only using one integer variable to keep track of the total number of 1s in the binary representation of a number.