## Dictionary Approach (double pass)
First we create a copy of each node and use a dictionary to map from old to new nodes. Then we set up the next and random pointers for the new copied nodes. This process involves two passes. Also note that we add the mapping `None: None` to our dictionary since the random pointer can be `None`, in which case this will be reflected in our copy, if we don't include this, when setting up the random pointers, we could get a key error.
``` python
"""
# Definition for a Node.
class Node:
    def __init__(self, x: int, next: 'Node' = None, random: 'Node' = None):
        self.val = int(x)
        self.next = next
        self.random = random
"""

class Solution:
    def copyRandomList(self, head: 'Optional[Node]') -> 'Optional[Node]':
        # Create mapping from old to new copies
        oldToNew = {None: None}
        curr = head
        while curr:
            copy = Node(curr.val)
            oldToNew[curr] = copy
            curr = curr.next
        
        # Construct new list
        curr = head
        while curr:
            copy = oldToNew[curr]
            copy.next = oldToNew[curr.next]
            copy.random = oldToNew[curr.random]
            curr = curr.next
        
        return oldToNew[head]
```
The time and space complexity are both O(n).
## Dictionary Approach (single pass)
