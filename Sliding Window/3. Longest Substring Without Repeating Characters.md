## Two Pointer Approach
We have two pointers, left and right. The left pointer is initialized to the beginning of the string, the right pointer is going to iterate through every character in the string and as it does, it adds that character to the set. If at any point, the character at the right pointer is already in the set, we are going remove the character at the left pointer from the set and move the left pointer once until the character at the right pointer is no longer in the set. The creates our sliding window, and each time we add a new character to the set, we set longest to the size of the longest substring we have seen without repeating characters.
``` python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        longest = 0
        charSet = set()
        left = 0
  
        for right in range(len(s)):
            if s[right] in charSet:
                while s[right] in charSet:
                    charSet.remove(s[left])
                    left += 1
            charSet.add(s[right])
            longest = max(longest, right - left + 1)

        return longest
```
The time complexity is O(n) in the worst case since we iterate through each element at most twice. The space complexity is O(n) in the worst case since it could be that the given string has no repeated characters, so we must store every character of the string in our set.
## Two Pointer (Optimized)
This approach is very similar to the 