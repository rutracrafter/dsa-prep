## Linear Scan Approach
The most straightforward way to approach this problem is to just run through the entire array, until we find the target, otherwise we return -1.
``` python
def search(self, nums: List[int], target: int) -> int:
	for i in range(len(nums)):
		if nums[i] == target:
			return i
	return -1
```
This does not solve the problem, however, since our solution needs to be O(log(n)) and this approach is O(n) in time complexity and O(1) space complexity.
## Binary Search Approach
Lets us use binary search to solve the problem, the power of binary search is that it keeps on halving the problem, until we are left with one element which will either be equal to the target or not. We start with a left and right pointer on either side of the array and a middle pointer, if target equals the middle element, we return its index, now if target is greater than the middle element, we move the left pointer to the middle, otherwise, we move the right pointer to the middle. We repeat this procedure to keep halving the problem until we reach the last element. We avoid the edge case of an empty array as input by having our while condition be left <= right and after the while finishes, we check to see if the middle element is our target or not as by this point the left and right pointers have passed each other so we know that our middle pointer is on the last possible element. 
``` python
def search(self, nums: List[int], target: int) -> int:
	l = 0
	r = len(nums) - 1
	while (l <= r):
		m = l + ((r - l) // 2)
		if target == nums[m]:
			return m
		elif target < nums[m]:
			r = m - 1
		else:
			l = m + 1
	if (nums[m] == target):
		return m
	else:
		return -1
```
Since we half the problem at each step of the way, our problem runs in O(log(n)) time while still being O(1) space complexity since we only need 3 pointers.